import { ge } from "Compare"
import Float from "Float"
import { identity } from "Function"
import Integer from "Integer"
import { pow } from "Math"
import Random from "Random"
import String from "String"
import { ansiColor } from "Terminal"

import {
  ANSI_BACKGROUND,
  ANSI_FOREGROUND,
  FULL_COLOR_CHANNEL,
  HALF_COLOR_CHANNEL,
} from "@/Constants"
import { hexFromInt, intFromHex, toHexString } from "@/Hexadecimal"
import { channelB, channelG, channelR } from "@/Math"
import { colorFromSeed } from "@/Random"



export alias Color a = #[a, a, a]
export BLACK = #[0, 0, 0]
export WHITE = #[FULL_COLOR_CHANNEL, FULL_COLOR_CHANNEL, FULL_COLOR_CHANNEL]

export toChannel = where {
  #[r, g, b] =>
    r | g | b
}

export toInteger = where {
  #[r, g, b] =>
    r + g + b
}

export toFloat = where {
  #[r, g, b] =>
    16 + (36 * (r / 255 * 5)) + (6 * (g / 255 * 5)) + (b / 255 * 5)
}

export fromFloat = (v) => {
  r = channelR(v)
  g = channelG(v)
  b = channelB(v)
  return #[r, g, b]
}

export fromHexString = pipe(
  intFromHex,
  fromFloat,
)

export hexFromInt
export toHexString

toList :: Color a -> List a
export toList = where {
  #[r, g, b] =>
    [r, g, b]
}

mixer :: (Color a -> Color a -> Color b) -> Color a -> Color a -> Color b
export mixer = (mix, a, b) => mix(a, b)

mapRGB :: (a -> b) -> (a -> b) -> (a -> b) -> Color a -> Color b
export mapRGB = (fnR, fnG, fnB, a) => where(a) {
  #[r, g, b] =>
    #[fnR(r), fnG(g), fnB(b)]
}

export mapR = mapRGB($, identity, identity)
export mapG = mapRGB(identity, $, identity)
export mapB = mapRGB(identity, identity, $)

change :: (a -> b) -> Color a -> Color b
export change = (fn, a) => mapRGB(fn, fn, fn)(a)

export toTupleFloat = change(Integer.toFloat)

export toTupleInt = change(Float.toInteger)

export invert = (x) => FULL_COLOR_CHANNEL - x

export rgbInvert = change(invert)

isMid = ge($, HALF_COLOR_CHANNEL)

// https://github.com/Qix-/color/blob/master/index.js#L263-L274
/*
luminosity() {
  // http://www.w3.org/TR/WCAG20/#relativeluminancedef
  const rgb = this.rgb().color;

  const lum = [];
  for (const [i, element] of rgb.entries()) {
    const chan = element / 255;
    lum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
  }

  return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
}
*/

luminance :: Color Float -> Float
export luminance = pipe(
  change(
    (el) => {
      chan = el / 255
      return if (chan < 0.04045) {
        chan / 12.92
      } else {
        pow(((chan + 0.055) / 1.055), 2.4)
      }
    },
  ),
  mapRGB((r) => r * 0.2126, (g) => g * 0.7152, (b) => b * 0.0722),
  toInteger,
)

isLuminous :: Color Float -> Boolean
isLuminous = pipe(
  luminance,
  isMid,
)

seeded :: String -> String -> List String
export seeded = (seedPrefix, str) => pipe(
  mappend(seedPrefix),
  Random.generateFromString,
  colorFromSeed,
  (color) => {
    black = pipe(
      toTupleFloat,
      isLuminous,
    )(color)
    return where(color) {
      #[r, g, b] =>
        do {
          blackChannel = black ? 0 : FULL_COLOR_CHANNEL
          return map(show)([
            ANSI_FOREGROUND,
            2,
            blackChannel,
            blackChannel,
            blackChannel,
            ANSI_BACKGROUND,
            2,
            r,
            g,
            b,
          ])
        }
    }
  },
)(str)

contrastByLuminance :: Color Float -> Color Float
export contrastByLuminance = pipe(
  luminance,
  (x) => !isMid(x) ? WHITE : BLACK,
)

colorize :: String -> String -> String
export colorize = (seed, raw) => pipe(
  seeded(seed),
  ansiColor($, raw),
)(raw)
