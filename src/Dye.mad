import { ge } from "Compare"
import Float from "Float"
import { identity } from "Function"
import Integer from "Integer"
import { length, range, reduce, reverse, zip } from "List"
import { pow } from "Math"
import Random from "Random"
import String from "String"
import { ansiColor } from "Terminal"

import {
  ANSI_BACKGROUND,
  ANSI_FOREGROUND,
  FULL_COLOR_CHANNEL,
  HALF_COLOR_CHANNEL,
} from "@/Constants"
import { channelB, channelG, channelR } from "@/Math"
import { colorFromSeed } from "@/Random"



export alias Color a = #[a, a, a]
export BLACK = #[0, 0, 0]
export WHITE = #[FULL_COLOR_CHANNEL, FULL_COLOR_CHANNEL, FULL_COLOR_CHANNEL]

export toChannel = where {
  #[r, g, b] =>
    r | g | b
}

export toInteger = where {
  #[r, g, b] =>
    r + g + b
}

export toFloat = where {
  #[r, g, b] =>
    16 + (36 * (r / 255 * 5)) + (6 * (g / 255 * 5)) + (b / 255 * 5)
}

hexChar :: Char -> Integer
hexChar = (c) => if (c == '0') {
  0
} else if (c == '1') {
  1
} else if (c == '2') {
  2
} else if (c == '3') {
  3
} else if (c == '4') {
  4
} else if (c == '5') {
  5
} else if (c == '6') {
  6
} else if (c == '7') {
  7
} else if (c == '8') {
  8
} else if (c == '9') {
  9
} else if (c == 'a' || c == 'A') {
  10
} else if (c == 'b' || c == 'B') {
  11
} else if (c == 'c' || c == 'C') {
  12
} else if (c == 'd' || c == 'D') {
  13
} else if (c == 'e' || c == 'E') {
  14
} else if (c == 'f' || c == 'F') {
  15
} else {
  -1
}


export fromHexString = (hex) => {
  clean = String.replace("#", "", hex)
  return pipe(
    String.split(""),
    length,
    range(0),
    reverse,
    zip(
      $,
      pipe(
        String.toList,
        map(hexChar),
      )(clean),
    ),
    reduce(
      (y, c) => where(c) {
        #[i, x] =>
          y + Float.fromInteger(x) * pow(16_f, Float.fromInteger(i))
      },
      0,
    ),
    Integer.fromFloat,
  )(clean)
}

export fromFloat = (v) => {
  r = channelR(v)
  g = channelG(v)
  b = channelB(v)
  return #[r, g, b]
}


toList :: Color a -> List a
export toList = where {
  #[r, g, b] =>
    [r, g, b]
}

mixer :: (Color a -> Color a -> Color b) -> Color a -> Color a -> Color b
export mixer = (mix, a, b) => mix(a, b)

mapRGB :: (a -> b) -> (a -> b) -> (a -> b) -> Color a -> Color b
export mapRGB = (fnR, fnG, fnB, a) => where(a) {
  #[r, g, b] =>
    #[fnR(r), fnG(g), fnB(b)]
}

export mapR = mapRGB($, identity, identity)
export mapG = mapRGB(identity, $, identity)
export mapB = mapRGB(identity, identity, $)

change :: (a -> b) -> Color a -> Color b
export change = (fn, a) => mapRGB(fn, fn, fn)(a)

export toTupleFloat = change(Integer.toFloat)

export toTupleInt = change(Float.toInteger)

export invert = (x) => FULL_COLOR_CHANNEL - x

export rgbInvert = change(invert)

isMid = ge($, HALF_COLOR_CHANNEL)

luminance :: Color Float -> Color Float
export luminance = mapRGB((r) => r * 0.2126, (g) => g * 0.7152, (b) => b * 0.0722)

isLuminous :: Color Float -> Boolean
isLuminous = pipe(
  luminance,
  toInteger,
  isMid,
)

seeded :: String -> String -> List String
export seeded = (seedPrefix, str) => pipe(
  mappend(seedPrefix),
  Random.generateFromString,
  colorFromSeed,
  (color) => {
    black = pipe(
      toTupleFloat,
      isLuminous,
    )(color)
    return where(color) {
      #[r, g, b] =>
        do {
          blackChannel = black ? 0 : FULL_COLOR_CHANNEL
          return map(show)([
            ANSI_FOREGROUND,
            2,
            blackChannel,
            blackChannel,
            blackChannel,
            ANSI_BACKGROUND,
            2,
            r,
            g,
            b,
          ])
        }
    }
  },
)(str)

contrastByLuminance :: Color Float -> Color Float
export contrastByLuminance = pipe(
  luminance,
  toFloat,
  (x) => !isMid(x) ? WHITE : BLACK,
)

colorize :: String -> String -> String
export colorize = (seed, raw) => pipe(
  seeded(seed),
  ansiColor($, raw),
)(raw)
